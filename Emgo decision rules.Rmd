---
title: "Emperor Goose Decision Rules"
author: "Erik Osnas"
date: "April 8, 2016"
output: html_document
---

```{r}
## Define important functions

HarvestPolicy <- function(n, plist = list()){
  hpol <- ifelse(n < plist[[1]], "Red", ifelse(n < plist[[2]],"Yellow","Green"))
  return(hpol)
}

ilogit <- function(x){exp(x)/(1+exp(x))}

utility <- function(n=NA, h=NA, par=list(npar=c(1,1), hpar=c(1))){
  #util.n <- 1 - exp(-par$npar[1]*n)
  util.n <- plogis(q=n, par$npar[1], par$npar[2])
  util.h <- 1 - exp(-par$hpar[1]*h)
  util <- (util.n + util.h)/2
  return(util)
}
```

Let first look at the untility function.

```{r echo=FALSE}
num=seq(1,2e5, length=100)
har=seq(1,1.5e4,length=100)
reward=matrix(NA, length(num), length(har))
for(i in 1:length(har)){
  reward[,i] = utility(n=num, h=har[i], par=list(npar=c(15.7e4, 3e4), hpar=1e-4))
}
image(reward, x=num, y=har)

plot(num, reward[,1])

plot(har, reward[100,])
```

Now let's calculate expected utility over time, given a starting population, harvest rule, and harvest distrubution within each harvest rule.

```{r echo=FALSE}

Reps <- 1000
T <- 30
N0 <- rnorm(Reps, 155000, 25000)
Rmax <- rlnorm(Reps, log(0.15), 0.1)
CC <- runif(Reps, 155000, 250000)
Theta <- 4*rbeta(Reps, 1, 1) + 1
sigma.proc <- rnorm(Reps, 0.143, 0.02)  ##~ from Stehn and Fleischman
cv.obs <- 0.1

t.min <- 50000
t.max <- 200000
t.delta <- 10000

Har = list(Red = rlnorm(Reps, log(3000), 0.1), 
              Yellow = rlnorm(Reps, log(7000), 0.1), 
              Green = rlnorm(Reps, log(15000), 0.2))
## Question:  Is harvest modelled correctly?  for each policy should be a grand mean as above and then a year effect with smaller variance?
thresholds = seq(t.min, t.max, by=t.delta)
e.util = matrix(NA, nrow=length(thresholds), ncol=length(thresholds))

for(ii in 1:length(thresholds)){for(jj in ii:length(thresholds)){
  
#define harvest thresholds
H.pol = list(Red = thresholds[ii], Yellow = thresholds[jj])

Results = list(N=array(NA, dim=c(Reps,T)), 
               N.obs = array(NA, dim=c(Reps,T)), 
               HarPol = array(NA, dim=c(Reps,T)),
               Har = array(NA, dim=c(Reps,T)),
               Utility = array(NA, dim=c(Reps,T))
               )

for(i in 1:Reps){
  N <- N.obs<- numeric()
  N[1] <- rnorm(1, N0[i], cv.obs*N0[i])
  N.obs[1] <- rnorm(1,N[1], cv.obs*N[1])
  for(t in 2:(T+1)){
    HarPol <- HarvestPolicy(n = N.obs[t-1], plist=H.pol)
    Results$HarPol[i,t-1] <- HarPol
    Results$Har[i,t-1] <- Har[[HarPol]][i]
    E.N.pre <- N[t-1]*exp(Rmax[i]*(1 - (N[t-1]/CC[i])^Theta[i]))
    N.pre <- ifelse(E.N.pre <= 0,0,rlnorm(1,log(E.N.pre), sigma.proc[i]))
    N[t] <- ifelse(N.pre - Har[[HarPol]][i] <= 0,0,N.pre - Har[[HarPol]][i])
    N.obs[t] <- ifelse(N[t]<=0,0,rnorm(1,N[t], cv.obs*N[t]))
  }
  Results$N[i,] <- N[-1]
  Results$N.obs[i,] <- N.obs[-1]
  Results$Utility[i,] <- utility(n = Results$N[i,], h = Results$Har[i,],par=list(npar=c(15.7e4, 3e4), hpar=1e-4))
}
e.util[ii,jj] <- mean(apply(Results$Utility,1,sum))
}}

smart.spot = which(e.util==max(e.util, na.rm=TRUE), arr.ind = TRUE)
harvest.rule=list(Red=thresholds[smart.spot[1]], Yellow=thresholds[smart.spot[2]])
harvest.rule
```

```{r}
#Simulate dynamics at smart threshold
H.pol = harvest.rule

Results = list(N=array(NA, dim=c(Reps,T)), 
               N.obs = array(NA, dim=c(Reps,T)), 
               HarPol = array(NA, dim=c(Reps,T)),
               Har = array(NA, dim=c(Reps,T)),
               Utility = array(NA, dim=c(Reps,T))
               )
for(i in 1:Reps){
  N <- N.obs<- numeric()
  N[1] <- rnorm(1, N0[i], cv.obs*N0[i])
  N.obs[1] <- rnorm(1,N[1], cv.obs*N[1])
  for(t in 2:(T+1)){
    HarPol <- HarvestPolicy(n = N.obs[t-1], plist=H.pol)
    Results$HarPol[i,t-1] <- HarPol
    Results$Har[i,t-1] <- Har[[HarPol]][i]
    E.N.pre <- N[t-1]*exp(Rmax[i]*(1 - (N[t-1]/CC[i])^Theta[i]))
    N.pre <- ifelse(E.N.pre <= 0,0,rlnorm(1,log(E.N.pre), sigma.proc[i]))
    N[t] <- ifelse(N.pre <= 0,0,N.pre - Har[[HarPol]][i])
    N.obs[t] <- ifelse(N[t]<=0,0,rnorm(1,N[t], cv.obs*N[t]))
  }
  Results$N[i,] <- N[-1]
  Results$N.obs[i,] <- N.obs[-1]
  Results$Utility[i,] <- utility(n = Results$N[i,], h = Results$Har[i,], par=list(npar=c(7.5e4, 1e4), hpar=1.5e-4))
}


p.regs <- as.matrix(table(Results$HarPol)/(T*Reps))
regs <- matrix(0, 3, 1)
row.names(regs) <- c("Red","Yellow","Green")

#library(scales)
plot(1,1, type="n",xlim=c(0, T), ylim=c(0, max(CC)), xlab="Year", ylab="Obs. Population")
for(i in 1:1000){
  lines(1:T, Results$N.obs[i,], col=1)
}
abline(h=H.pol, col=c("Red", "Yellow"), lwd=3)
text(x=2*(1:dim(p.regs)[1]), y=4e4, labels=row.names(p.regs))
text(x=2*(1:dim(p.regs)[1]), y=2e4, labels=round(p.regs,2))

plot(1,1, type="n",xlim=c(0, T), ylim=c(0, max(CC)), xlab="Year", ylab="True Population")
for(i in 1:1000){
  lines(1:T, Results$N[i,], col=1)
}
abline(h=H.pol, col=c("Red", "Yellow"), lwd=3)
text(x=2*(1:dim(p.regs)[1]), y=4e4, labels=row.names(p.regs))
text(x=2*(1:dim(p.regs)[1]), y=2e4, labels=round(p.regs,2))
```

plot(1,1, type="n",xlim=c(0, T), ylim=c(0, max(CC)), xlab="Year", ylab="True Population")
for(i in 1:10){
  lines(1:T, Results$N[i,], col=1)
  lines(1:T, Results$N.obs[i,], col=2)
}


